<document>
  <body>
    <section name="Modules">
      <subsection name="Creating a Module">
	<p>To start, we need to create a Module or many modules to be used in a workflow.  Take a look at the Echo.java module class.</p>
	<pre><![CDATA[
@Application(name = "Echo", isWorkflowRunIdOptional = true)
@Executable(value = "/bin/echo")
public class Echo extends Module {

    @Size(min = 0, message = "Greeting is required", groups = InputValidations.class)
    @NotNull(message = "Greeting is required", groups = InputValidations.class)
    @InputArgument(delimiter = "")
    private String greeting;

    @FileIsReadable(message = "File does not exist", groups = OutputValidations.class)
    @NotNull(message = "Output file name is required", groups = InputValidations.class)
    @OutputArgument(redirect = true, persistFileData = true)
    private File output;

    public Echo() {
        super();
    }

    @Override
    public Class<?> getModuleClass() {
        return Echo.class;
    }

    public String getGreeting() {
        return greeting;
    }

    public void setGreeting(String greeting) {
        this.greeting = greeting;
    }

    public File getOutput() {
        return output;
    }

    public void setOutput(File output) {
        this.output = output;
    }

}
]]></pre>
	<p>The contents of this module include: annotations housing declarative metadata, member variables with cooresponding getters and setters, and a call() method that returns a ModuleOutput class.  The class level annotations declare metadata about the application whereas the annotations at the member variable level define inputs, outputs, and JSR 303 validation constraints.</p>
	<p>Note that the Echo class extends an AbstractModule class.  The AbstractModule class implements Module and partially implements a Module's lifecycle methods init() and cleanUp().   These lifecycle methods are intended to be overridden in the subclass.  AbstractModule also provides a cache for a workflowRunId, a sequencerRunId, a set of related Processing objects, and a set of FileData objects.</p>
      </subsection>
      <subsection name="Where to put the code?">
	<p>The "&lt;mapseq&gt;/mapseq-modules/" directory houses sub-projects in an attempt to organize Modules into a groups.  For example, "&lt;mapseq&gt;/mapseq-modules/mapseq-module-picard" houses <a href="http://picard.sourceforge.net/">Picard</a> related Modules which, not suprisingly, wrap Picard executables.  One will not find Modules pertaining to BWA in the Picard module sub-project and vice-versa, no Picard modules will be found in the BWA sub-project.</p>
	<p>Please respect the package structure conventions: edu.unc.mapseq.module.&lt;associative group name&gt;.  (ie, Picard modules are found in edu.unc.mapseq.module.picard)</p>
      </subsection>
      <subsection name="Notes">
	<p>See <a href="mapseq-modules/index.html">MaPSeq Modules</a> for examples and assumptions.</p>
	<p>For a more complete list of Bean Validation annotations, please see the <a href="http://docs.jboss.org/hibernate/validator/4.2/api/">Hibernate Validator Javadocs</a></p>
	<p>For building your own custom Bean Validation constraints, please see <a href="http://docs.jboss.org/hibernate/validator/4.0.1/reference/en/html/validator-customconstraints.html">this documentation</a>.</p>
	<p>See <a href="build.html">build instructions</a>.</p>
	<p><a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">Maven directory structure conventions</a></p>
      </subsection>
    </section>
    <p><span id="pageNavLeft"><a href="frontToEndIntegration.html"> &lt;&lt; Back</a></span><span id="pageNavRight"><a href="frontToEndIntegration-step2.html">Continue &gt;&gt;</a></span></p>
  </body>
</document>
